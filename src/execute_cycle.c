#include <dispatcher.h>
#include <avm-reader.h>

#include <assert.h>

/* Variables used for execution */
unsigned pc = 0;
unsigned currLine = 0;
unsigned executionFinished = 0;

/* typedefinition of the executeFuncs table */
typedef void (*exec_func_t)(Instruction_T);

static exec_func_t executeFuncs[] = {
	
	/* Assignment opcode */
	execute_assign,
    
	/* Airthmetic opcodes */
	execute_add,
    execute_sub,
    execute_mul,
    execute_div,
    execute_mod,
    execute_uminus,
    
	/* Jump opcode */
    execute_jump,

	/* Branch opcodes */
    execute_jeq,
    execute_jne,
    execute_jgt,
    execute_jge,
    execute_jlt,
	execute_jle,

	/* call related opcodes */
    execute_call,
    execute_pusharg,

	/* function defintion related opcode */
    execute_funcenter,
    execute_funcexit,

	/* Boolean expression related opcode */
    execute_or,
    execute_and,
    execute_not,

	/* Table related opcodes */
    execute_newtable,
    execute_tablegetelem, 
    execute_tablesetelem,

	/* NOP */
    execute_nop
};

/*
 This FSM is used to execute one by one sequentialy 
 all the isntructions generated by the compiler
*/
void execute_cycle (void) {

    if (executionFinished) 
	{
        return;
    }
	else
	if (pc == AVM_ENDING_PC)
	{
        executionFinished = 1;
        return;
    }
	else
	{
        assert(pc < AVM_ENDING_PC);
    
	    Instruction_T instr = code + pc;
		 
		/* Check if the opcode is valid */
        assert(instr->opcode >= 0 && instr->opcode <= nop_v);

        if (instr->srcLine)
            currLine = instr->srcLine;

        unsigned oldPC = pc;

        (*executeFuncs[instr->opcode])(instr);

        if (pc == oldPC)
            ++pc;
    }

	return ;
}